const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');
const bodyParser = require('body-parser');
const helmet = require('helmet');
const morgan = require('morgan');
const path = require('path');
const config = require('./config/config');
const { DatabaseCacheManager } = require('./modules/sistemaCache');
const PaginationManager = require('./modules/sistemaPaginacion');
const { LoggerFactory } = require('./modules/sistemaLogging');

// Exportar la instancia de la base de datos para uso en otros m√≥dulos
let db;
let cacheManager;
let paginationManager;
let logger;

// Inicializar logger
logger = LoggerFactory.create(config.getAll());

// Inicializar sistemas de rendimiento
async function initPerformanceSystems() {
    try {
        // Inicializar sistema de cach√©
        cacheManager = new DatabaseCacheManager(config.getAll());
        logger.systemEvent('Sistema de cach√© inicializado');
        
        // Inicializar sistema de paginaci√≥n
        paginationManager = new PaginationManager(config.getAll());
        paginationManager.setDatabase(db);
        
        // Crear √≠ndices optimizados
        await paginationManager.createPaginationIndexes();
        logger.systemEvent('Sistema de paginaci√≥n inicializado');
        
        // Precalentar cach√© con datos frecuentes
        await preheatCache();
        
    } catch (error) {
        logger.error('Error inicializando sistemas de rendimiento', { error: error.message });
    }
}

// Precalentar cach√© con datos frecuentes
async function preheatCache() {
    const fetchFunctions = {
        'empresas:all': () => new Promise((resolve, reject) => {
            db.all('SELECT * FROM empresas ORDER BY nombre', (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        }),
        'productos:all': () => new Promise((resolve, reject) => {
            db.all('SELECT * FROM productos WHERE activo = 1 ORDER BY descripcion', (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        }),
        'clientes:count': () => new Promise((resolve, reject) => {
            db.get('SELECT COUNT(*) as count FROM clientes', (err, row) => {
                if (err) reject(err);
                else resolve(row.count);
            });
        }),
        'facturas:count': () => new Promise((resolve, reject) => {
            db.get('SELECT COUNT(*) as count FROM facturas', (err, row) => {
                if (err) reject(err);
                else resolve(row.count);
            });
        })
    };
    
    await cacheManager.preheat(fetchFunctions);
    logger.systemEvent('Cach√© precalentado con datos frecuentes');
}

// M√≥dulos para cumplir con la Ley Antifraude
const SistemaIntegridad = require('./modules/sistemaIntegridad');
const SistemaAuditoria = require('./modules/sistemaAuditoria');
const GeneradorVeriFactu = require('./modules/generadorVeriFactu');
const SistemaBackup = require('./modules/sistemaBackup');
const SistemaCifrado = require('./modules/sistemaCifrado');
const SistemaControlAcceso = require('./modules/sistemaControlAcceso');
const SistemaLogsSeguridad = require('./modules/sistemaLogsSeguridad');
const SistemaValidacionFiscal = require('./modules/sistemaValidacionFiscal');
const SistemaFirmaDigital = require('./modules/sistemaFirmaDigital');

const app = express();
const PORT = config.get('server.port');
const HOST = config.get('server.host');

// Middleware
if (config.get('security.helmet')) {
    app.use(helmet());
}

// Middleware de logging optimizado
app.use((req, res, next) => {
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - start;
        logger.apiRequest(req.method, req.url, res.statusCode, duration);
    });
    
    next();
});

app.use(cors(config.get('server.cors')));
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '10mb' }));

// Cargar configuraci√≥n din√°mica de empresa
let configuracionEmpresa = null;
config.loadFromDatabase().then(() => {
    configuracionEmpresa = config.get('empresa');
    logger.systemEvent('Configuraci√≥n de empresa cargada', { empresa: configuracionEmpresa.nombre });
});

// Inicializar base de datos
const dbPath = config.get('database.path');
db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) => {
    if (err) {
        logger.error('Error al conectar con la base de datos', { error: err.message });
    } else {
        logger.systemEvent('Base de datos conectada exitosamente');
        
        // Configurar la base de datos para mejor manejo de concurrencia
        db.run(`PRAGMA busy_timeout = ${config.get('database.timeout')}`);
        db.run(`PRAGMA journal_mode = ${config.get('database.journalMode')}`);
        db.run(`PRAGMA synchronous = ${config.get('database.synchronous')}`);
        db.run(`PRAGMA cache_size = ${config.get('database.cacheSize')}`);
        
        initDatabase();
    }
});

// Funci√≥n utilitaria para ejecutar operaciones de base de datos con reintentos
function ejecutarConReintentos(operacion, maxReintentos = 3, delay = 100) {
    return new Promise((resolve, reject) => {
        let intentos = 0;
        
        function intentar() {
            operacion()
                .then(resolve)
                .catch(err => {
                    if (err.code === 'SQLITE_BUSY' && intentos < maxReintentos) {
                        intentos++;
                        console.log(`‚ö†Ô∏è Base de datos ocupada, reintentando... (${intentos}/${maxReintentos})`);
                        setTimeout(intentar, delay * intentos);
                    } else {
                        reject(err);
                    }
                });
        }
        
        intentar();
    });
}

// Inicializar m√≥dulos de la Ley Antifraude
let sistemaIntegridad, sistemaAuditoria, generadorVeriFactu, sistemaBackup;
let sistemaCifrado, sistemaControlAcceso, sistemaLogsSeguridad, sistemaValidacionFiscal;
let sistemaFirmaDigital;

// Funci√≥n para inicializar m√≥dulos despu√©s de la base de datos
function initModulosAntifraude() {
    try {
        sistemaIntegridad = new SistemaIntegridad();
        sistemaAuditoria = new SistemaAuditoria(db);
        generadorVeriFactu = new GeneradorVeriFactu();
        sistemaBackup = new SistemaBackup(db, {
            directorioBackup: './backups',
            frecuenciaBackup: 24 * 60 * 60 * 1000, // 24 horas
            retencionDias: 1460 // 4 a√±os
        });
        
        // Nuevos m√≥dulos de seguridad
        sistemaCifrado = new SistemaCifrado();
        sistemaControlAcceso = new SistemaControlAcceso(db);
        sistemaLogsSeguridad = new SistemaLogsSeguridad(db);
        sistemaValidacionFiscal = new SistemaValidacionFiscal();
        sistemaFirmaDigital = new SistemaFirmaDigital();
        
        // Inicializar sistemas que requieren base de datos
        sistemaControlAcceso.inicializar();
        sistemaLogsSeguridad.inicializar();
        
        // Iniciar backup autom√°tico
        sistemaBackup.iniciarBackupAutomatico();
        
        console.log('‚úÖ M√≥dulos de Ley Antifraude inicializados correctamente');
        console.log('üîí Sistema de cifrado activado');
        console.log('üõ°Ô∏è Sistema de control de acceso activado');
        console.log('üìã Sistema de logs de seguridad activado');
        console.log('‚úÖ Sistema de validaci√≥n fiscal activado');
        console.log('üîê Sistema de firma digital activado');
        console.log('üíæ Sistema de backup autom√°tico activado');
        
        // Configurar endpoints de seguridad despu√©s de la inicializaci√≥n
        configurarEndpointsSeguridad();
    } catch (error) {
        console.error('‚ùå Error al inicializar m√≥dulos de Ley Antifraude:', error);
    }
}

// Inicializar tablas
function initDatabase() {
    logger.systemEvent('Inicializando base de datos');
    
    // Crear tablas secuencialmente
    db.serialize(() => {
        // Tabla de clientes
        db.run(`
            CREATE TABLE IF NOT EXISTS clientes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nombre TEXT NOT NULL,
                direccion TEXT NOT NULL,
                codigo_postal TEXT,
                identificacion TEXT UNIQUE NOT NULL,
                email TEXT,
                telefono TEXT,
                fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, (err) => {
            if (err) {
                logger.error('Error al crear tabla clientes', { error: err.message });
            } else {
                logger.debug('Tabla clientes creada/verificada');
                // A√±adir columna codigo_postal si no existe
                db.run('ALTER TABLE clientes ADD COLUMN codigo_postal TEXT', (err) => {
                    if (err && !err.message.includes('duplicate column name')) {
                        logger.error('Error al a√±adir columna codigo_postal', { error: err.message });
                    }
                });
            }
        });

        // Tabla de empresas
        db.run(`
            CREATE TABLE IF NOT EXISTS empresas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nombre TEXT NOT NULL,
                cif TEXT UNIQUE NOT NULL,
                direccion TEXT NOT NULL,
                telefono TEXT,
                email TEXT,
                certificado_thumbprint TEXT,
                fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, (err) => {
            if (err) {
                console.error('‚ùå Error al crear tabla empresas:', err.message);
            } else {
                console.log('‚úÖ Tabla empresas creada/verificada');
            }
        });

        // Tabla de coches
        db.run(`
            CREATE TABLE IF NOT EXISTS coches (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                matricula TEXT UNIQUE NOT NULL,
                chasis TEXT NOT NULL,
                color TEXT NOT NULL,
                kms INTEGER NOT NULL,
                modelo TEXT NOT NULL,
                activo BOOLEAN DEFAULT 1,
                fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, (err) => {
            if (err) {
                console.error('‚ùå Error al crear tabla coches:', err.message);
            } else {
                console.log('‚úÖ Tabla coches creada/verificada');
            }
        });

        // Tabla de productos/veh√≠culos
        db.run(`
            CREATE TABLE IF NOT EXISTS productos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                codigo TEXT UNIQUE NOT NULL,
                descripcion TEXT NOT NULL,
                precio REAL NOT NULL,
                stock INTEGER DEFAULT 0,
                categoria TEXT DEFAULT 'vehiculo',
                activo BOOLEAN DEFAULT 1,
                fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, (err) => {
            if (err) {
                console.error('‚ùå Error al crear tabla productos:', err.message);
            } else {
                console.log('‚úÖ Tabla productos creada/verificada');
            }
        });

        // Tabla de facturas
        db.run(`
            CREATE TABLE IF NOT EXISTS facturas (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                numero_factura TEXT NOT NULL,
                empresa_id INTEGER NOT NULL,
                cliente_id INTEGER,
                fecha_emision DATE NOT NULL,
                fecha_vencimiento DATE,
                subtotal REAL NOT NULL,
                igic REAL NOT NULL,
                total REAL NOT NULL,
                estado TEXT DEFAULT 'pendiente',
                notas TEXT,
                fecha_creacion DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (empresa_id) REFERENCES empresas (id),
                FOREIGN KEY (cliente_id) REFERENCES clientes (id),
                UNIQUE(numero_factura, empresa_id)
            )
        `, (err) => {
            if (err) {
                console.error('‚ùå Error al crear tabla facturas:', err.message);
            } else {
                console.log('‚úÖ Tabla facturas creada/verificada');
            }
        });

        // Tabla de detalles de factura
        db.run(`
            CREATE TABLE IF NOT EXISTS detalles_factura (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                factura_id INTEGER,
                producto_id INTEGER,
                cantidad INTEGER NOT NULL,
                precio_unitario REAL NOT NULL,
                subtotal REAL NOT NULL,
                igic REAL NOT NULL,
                total REAL NOT NULL,
                descripcion TEXT,
                tipo_impuesto TEXT DEFAULT 'igic',
                FOREIGN KEY (factura_id) REFERENCES facturas (id),
                FOREIGN KEY (producto_id) REFERENCES productos (id)
            )
        `, (err) => {
            if (err) {
                console.error('‚ùå Error al crear tabla detalles_factura:', err.message);
            } else {
                console.log('‚úÖ Tabla detalles_factura creada/verificada');
                
                // Agregar columna descripcion si no existe (migraci√≥n)
                db.run(`ALTER TABLE detalles_factura ADD COLUMN descripcion TEXT`, (err) => {
                    if (err && !err.message.includes('duplicate column name')) {
                        console.error('‚ùå Error al agregar columna descripcion:', err.message);
                    } else if (!err) {
                        console.log('‚úÖ Columna descripcion agregada a detalles_factura');
                    }
                });
                
                // Agregar columna tipo_impuesto si no existe (migraci√≥n)
                db.run(`ALTER TABLE detalles_factura ADD COLUMN tipo_impuesto TEXT DEFAULT 'igic'`, (err) => {
                    if (err && !err.message.includes('duplicate column name')) {
                        console.error('‚ùå Error al agregar columna tipo_impuesto:', err.message);
                    } else if (!err) {
                        console.log('‚úÖ Columna tipo_impuesto agregada a detalles_factura');
                    }
        });

        // Tabla de auditor√≠a (para cumplir con Ley Antifraude)
        db.run(`
            CREATE TABLE IF NOT EXISTS audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tabla TEXT NOT NULL,
                registro_id INTEGER NOT NULL,
                operacion TEXT NOT NULL,
                datos_anteriores TEXT,
                datos_nuevos TEXT,
                usuario_id INTEGER,
                fecha_operacion DATETIME DEFAULT CURRENT_TIMESTAMP,
                ip_address TEXT,
                user_agent TEXT
            )
        `, (err) => {
            if (err) {
                logger.error('Error al crear tabla audit_log', { error: err.message });
            } else {
                logger.debug('Tabla audit_log creada/verificada');
            }
        });

        // Insertar datos de ejemplo despu√©s de crear todas las tablas
        insertSampleData();
                
                // Inicializar m√≥dulos de Ley Antifraude
                initModulosAntifraude();
                
                // Inicializar sistemas de rendimiento
                initPerformanceSystems();
            }
        });
    });
}

// Insertar datos de ejemplo de forma silenciosa
function insertSampleData() {
    // Insertar empresa Telwagen
    db.run(`
        INSERT OR IGNORE INTO empresas (nombre, cif, direccion, telefono, email)
        VALUES (?, ?, ?, ?, ?)
    `, [
        'Telwagen Car Ib√©rica, S.L.',
        'B-93.289.585',
        'C. / Tom√°s Miller N¬∞ 48 Local\n35007 Las Palmas de Gran Canaria',
        '+34 928 123 456',
        'info@telwagen.es'
    ]);

    // Insertar cliente de ejemplo
    db.run(`
        INSERT OR IGNORE INTO clientes (nombre, direccion, identificacion, email, telefono)
        VALUES (?, ?, ?, ?, ?)
    `, [
        'GRUPO MIGUEL LEON S.L.',
        'C/. ALFREDO MARTIN REYES N¬∞ 7\nLAS PALMAS DE G.C.',
        'B76233865',
        'info@grupomiguelleon.es',
        '+34 928 123 456'
    ]);

    // Insertar coches de ejemplo (solo algunos para reducir logs)
    const cochesEjemplo = [
        { matricula: 'GC-1234-AB', marca: 'NISSAN', modelo: 'MICRA', a√±o: 2020, precio: 15000 },
        { matricula: 'GC-5678-CD', marca: 'NISSAN', modelo: 'QASHQAI', a√±o: 2021, precio: 25000 },
        { matricula: 'GC-9012-EF', marca: 'NISSAN', modelo: 'LEAF', a√±o: 2022, precio: 35000 }
    ];

    cochesEjemplo.forEach(coche => {
        db.run(`
            INSERT OR IGNORE INTO coches (matricula, marca, modelo, a√±o, precio, activo)
            VALUES (?, ?, ?, ?, ?, ?)
        `, [coche.matricula, coche.marca, coche.modelo, coche.a√±o, coche.precio, 1]);
    });

    // Insertar productos de ejemplo (solo algunos)
    const productosEjemplo = [
        { codigo: 'NISSAN-MICRA-1.0', descripcion: 'Nissan Micra 1.0', precio: 15000, categoria: 'vehiculo' },
        { codigo: 'NISSAN-QASHQAI-1.3', descripcion: 'Nissan Qashqai 1.3', precio: 25000, categoria: 'vehiculo' },
        { codigo: 'NISSAN-LEAF-40KWH', descripcion: 'Nissan Leaf 40kWh', precio: 35000, categoria: 'vehiculo' }
    ];

    productosEjemplo.forEach(producto => {
        db.run(`
            INSERT OR IGNORE INTO productos (codigo, descripcion, precio, categoria, activo)
            VALUES (?, ?, ?, ?, ?)
        `, [producto.codigo, producto.descripcion, producto.precio, producto.categoria, 1]);
    });
}

    // Coches de ejemplo
    const cochesEjemplo = [
        {
            matricula: 'GC-1234-AB',
            chasis: 'WBAVB13506PT12345',
            color: 'Blanco',
            kms: 45000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-5678-CD',
            chasis: 'WVWZZZ1KZAW123456',
            color: 'Negro',
            kms: 32000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-9012-EF',
            chasis: 'WDDNG7JB0FA123456',
            color: 'Azul',
            kms: 28000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-3456-GH',
            chasis: 'WBAVB13506PT12346',
            color: 'Gris',
            kms: 52000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-7890-IJ',
            chasis: 'WVWZZZ1KZAW123457',
            color: 'Rojo',
            kms: 38000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-2345-KL',
            chasis: 'WDDNG7JB0FA123457',
            color: 'Verde',
            kms: 15000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-6789-MN',
            chasis: 'WBAVB13506PT12348',
            color: 'Negro',
            kms: 67000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-0123-OP',
            chasis: 'WVWZZZ1KZAW123458',
            color: 'Blanco',
            kms: 42000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-4567-QR',
            chasis: 'WDDNG7JB0FA123458',
            color: 'Azul',
            kms: 33000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-8901-ST',
            chasis: 'WBAVB13506PT12349',
            color: 'Gris',
            kms: 28000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-2345-UV',
            chasis: 'WVWZZZ1KZAW123459',
            color: 'Rojo',
            kms: 55000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-6789-WX',
            chasis: 'WDDNG7JB0FA123459',
            color: 'Negro',
            kms: 19000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-0123-YZ',
            chasis: 'WBAVB13506PT12350',
            color: 'Blanco',
            kms: 41000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-4567-AA',
            chasis: 'WVWZZZ1KZAW123460',
            color: 'Verde',
            kms: 36000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-8901-BB',
            chasis: 'WDDNG7JB0FA123460',
            color: 'Gris',
            kms: 24000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-2345-CC',
            chasis: 'WBAVB13506PT12351',
            color: 'Azul',
            kms: 48000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-6789-DD',
            chasis: 'WVWZZZ1KZAW123461',
            color: 'Negro',
            kms: 29000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-0123-EE',
            chasis: 'WDDNG7JB0FA123461',
            color: 'Blanco',
            kms: 17000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-4567-FF',
            chasis: 'WBAVB13506PT12352',
            color: 'Rojo',
            kms: 39000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-8901-GG',
            chasis: 'WVWZZZ1KZAW123462',
            color: 'Gris',
            kms: 44000,
            modelo: 'Volkswagen Golf'
        },
        {
            matricula: 'GC-2345-HH',
            chasis: 'WDDNG7JB0FA123462',
            color: 'Negro',
            kms: 22000,
            modelo: 'Mercedes-Benz Clase A'
        },
        {
            matricula: 'GC-6789-II',
            chasis: 'WBAVB13506PT12353',
            color: 'Azul',
            kms: 51000,
            modelo: 'BMW 320i'
        },
        {
            matricula: 'GC-0123-JJ',
            chasis: 'WVWZZZ1KZAW123463',
            color: 'Blanco',
            kms: 31000,
            modelo: 'Volkswagen Golf'
        }
    ];

    // Funci√≥n para insertar coches de forma secuencial con reintentos
    async function insertarCoches() {
        for (const coche of cochesEjemplo) {
            try {
                await ejecutarConReintentos(() => {
                    return new Promise((resolve, reject) => {
                        db.run(`
                            INSERT OR IGNORE INTO coches (matricula, chasis, color, kms, modelo)
                            VALUES (?, ?, ?, ?, ?)
                        `, [coche.matricula, coche.chasis, coche.color, coche.kms, coche.modelo], (err) => {
                            if (err) {
                                reject(err);
                            } else {
                                resolve();
                            }
                        });
                    });
                });
                // Sin log de √©xito para reducir verbosidad
            } catch (err) {
                logger.error('Error al insertar coche', { matricula: coche.matricula, error: err.message });
                // Continuar con el siguiente coche en caso de error
            }
        }
    }

    // Ejecutar inserci√≥n de coches
    insertarCoches();

    // Productos de ejemplo
    const productosEjemplo = [
        { codigo: 'NISSAN-MICRA-1.0', descripcion: 'NISSAN MICRA 1.0 IGT ACENTA 92-100 CV', precio: 9589.04 },
        { codigo: 'NISSAN-QASHQAI-1.3', descripcion: 'NISSAN QASHQAI 1.3 DIG-T ACENTA 140 CV', precio: 18950.00 },
        { codigo: 'NISSAN-LEAF-40KWH', descripcion: 'NISSAN LEAF 40 kWh ACENTA', precio: 28990.00 },
        { codigo: 'NISSAN-JUKE-1.0', descripcion: 'NISSAN JUKE 1.0 DIG-T ACENTA 117 CV', precio: 15990.00 }
    ];

    // Funci√≥n para insertar productos de forma secuencial con reintentos
    async function insertarProductos() {
        for (const producto of productosEjemplo) {
            try {
                await ejecutarConReintentos(() => {
                    return new Promise((resolve, reject) => {
                        db.run(`
                            INSERT OR IGNORE INTO productos (codigo, descripcion, precio, stock)
                            VALUES (?, ?, ?, ?)
                        `, [producto.codigo, producto.descripcion, producto.precio, 10], (err) => {
                            if (err) {
                                reject(err);
                            } else {
                                resolve();
                            }
                        });
                    });
                });
                // Sin log de √©xito para reducir verbosidad
            } catch (err) {
                logger.error('Error al insertar producto', { codigo: producto.codigo, error: err.message });
                // Continuar con el siguiente producto en caso de error
            }
        }
    }

    // Ejecutar inserci√≥n de productos
    insertarProductos();

    console.log('‚úÖ Datos de ejemplo insertados');
}

// Endpoint para obtener configuraci√≥n de empresa
app.get('/api/configuracion/empresa', (req, res) => {
    if (configuracionEmpresa) {
        res.json({
            success: true,
            data: configuracionEmpresa
        });
    } else {
        res.json({
            success: false,
            error: 'Configuraci√≥n de empresa no disponible'
        });
    }
});

// Rutas API

// GET - Obtener todas las empresas (con paginaci√≥n y cach√©)
app.get('/api/empresas', async (req, res) => {
    try {
        const { page = 1, limit = 20, search = '' } = req.query;
        
        // Usar cach√© si est√° disponible
        const cacheKey = `empresas:page:${page}:limit:${limit}:search:${search}`;
        const cachedResult = cacheManager.get(cacheKey);
        
        if (cachedResult) {
            return res.json({ success: true, data: cachedResult.data, pagination: cachedResult.pagination, cached: true });
        }
        
        // Construir consulta con b√∫squeda
        let whereClause = '';
        let whereParams = [];
        
        if (search) {
            whereClause = 'WHERE nombre LIKE ? OR cif LIKE ?';
            whereParams = [`%${search}%`, `%${search}%`];
        }
        
        const result = await paginationManager.getPaginatedData('empresas', {
            page: parseInt(page),
            limit: parseInt(limit),
            where: whereClause,
            whereParams: whereParams,
            orderBy: 'nombre',
            orderDirection: 'ASC'
        });
        
        // Guardar en cach√©
        cacheManager.set(cacheKey, result, 300); // 5 minutos TTL
        
        res.json({ success: true, data: result.data, pagination: result.pagination, cached: false });
        
    } catch (error) {
        console.error('‚ùå Error al obtener empresas:', error);
        res.status(500).json({ error: error.message });
    }
});

// GET - Obtener empresa por ID
app.get('/api/empresas/:id', (req, res) => {
    const { id } = req.params;
    
    db.get('SELECT * FROM empresas WHERE id = ?', [id], (err, row) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (!row) {
            res.status(404).json({ error: 'Empresa no encontrada' });
            return;
        }
        res.json({ success: true, data: row });
    });
});

// POST - Crear nueva empresa
app.post('/api/empresas', (req, res) => {
    const { nombre, cif, direccion, telefono, email } = req.body;
    
    db.run(`
        INSERT INTO empresas (nombre, cif, direccion, telefono, email)
        VALUES (?, ?, ?, ?, ?)
    `, [nombre, cif, direccion, telefono, email], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ 
            success: true, 
            data: { 
                id: this.lastID, 
                nombre, 
                cif, 
                direccion, 
                telefono, 
                email
            } 
        });
    });
});

// PUT - Actualizar empresa
app.put('/api/empresas/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { nombre, cif, direccion, telefono, email, firmaDigitalThumbprint } = req.body;
        
        // Actualizar datos b√°sicos de la empresa
        await new Promise((resolve, reject) => {
            db.run(`
                UPDATE empresas 
                SET nombre = ?, cif = ?, direccion = ?, telefono = ?, email = ?, certificado_thumbprint = ?
                WHERE id = ?
            `, [nombre, cif, direccion, telefono, email, firmaDigitalThumbprint || null, id], function(err) {
                if (err) {
                    reject(err);
                } else if (this.changes === 0) {
                    reject(new Error('Empresa no encontrada'));
                } else {
                    resolve();
                }
            });
        });
        
        // Si se especifica una firma digital, asociarla con la empresa
        if (firmaDigitalThumbprint) {
            try {
                const resultadoAsociacion = await sistemaFirmaDigital.asociarCertificadoConEmpresa(id, firmaDigitalThumbprint);
                
                if (resultadoAsociacion.success) {
                    console.log(`‚úÖ Firma digital asociada con empresa ${nombre}: ${resultadoAsociacion.certificado.empresa}`);
                } else {
                    console.log(`‚ö†Ô∏è No se pudo asociar firma digital: ${resultadoAsociacion.error}`);
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è Error al asociar firma digital: ${error.message}`);
            }
        }
        
        res.json({ 
            success: true, 
            message: 'Empresa actualizada correctamente',
            firmaDigitalAsociada: firmaDigitalThumbprint ? true : false
        });
        
    } catch (error) {
        console.error('Error al actualizar empresa:', error);
        res.status(500).json({ 
            success: false,
            error: error.message 
        });
    }
});

// DELETE - Eliminar empresa (eliminaci√≥n f√≠sica)
app.delete('/api/empresas/:id', (req, res) => {
    const { id } = req.params;
    
    db.run('DELETE FROM empresas WHERE id = ?', [id], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (this.changes === 0) {
            res.status(404).json({ error: 'Empresa no encontrada' });
            return;
        }
        res.json({ success: true, message: 'Empresa eliminada correctamente' });
    });
});

// POST - Limpiar y recrear datos de ejemplo
app.post('/api/reset-data', (req, res) => {
    console.log('üîÑ Limpiando y recreando datos de ejemplo...');
    
    db.serialize(() => {
        // Limpiar tablas
        db.run('DELETE FROM empresas', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar empresas:', err.message);
            } else {
                console.log('‚úÖ Tabla empresas limpiada');
            }
        });
        
        db.run('DELETE FROM productos', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar productos:', err.message);
            } else {
                console.log('‚úÖ Tabla productos limpiada');
            }
        });
        
        db.run('DELETE FROM clientes', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar clientes:', err.message);
            } else {
                console.log('‚úÖ Tabla clientes limpiada');
            }
        });
        
        db.run('DELETE FROM coches', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar coches:', err.message);
            } else {
                console.log('‚úÖ Tabla coches limpiada');
            }
        });
        
        db.run('DELETE FROM facturas', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar facturas:', err.message);
            } else {
                console.log('‚úÖ Tabla facturas limpiada');
            }
        });
        
        db.run('DELETE FROM detalles_factura', (err) => {
            if (err) {
                console.error('‚ùå Error al limpiar detalles_factura:', err.message);
            } else {
                console.log('‚úÖ Tabla detalles_factura limpiada');
            }
        });
        
        // Recrear datos de ejemplo
        setTimeout(() => {
            insertSampleData();
            res.json({ success: true, message: 'Datos de ejemplo recreados correctamente' });
        }, 1000);
    });
});

// GET - Obtener todos los clientes
app.get('/api/clientes', (req, res) => {
    db.all('SELECT * FROM clientes ORDER BY fecha_creacion DESC', (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ success: true, data: rows });
    });
});

// POST - Crear nuevo cliente
app.post('/api/clientes', (req, res) => {
    const { nombre, direccion, codigo_postal, identificacion, email, telefono } = req.body;
    
    db.run(`
        INSERT INTO clientes (nombre, direccion, codigo_postal, identificacion, email, telefono)
        VALUES (?, ?, ?, ?, ?, ?)
    `, [nombre, direccion, codigo_postal, identificacion, email, telefono], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ 
            success: true, 
            data: { 
                id: this.lastID, 
                nombre, 
                direccion, 
                codigo_postal,
                identificacion, 
                email, 
                telefono 
            } 
        });
    });
});

// GET - Obtener cliente por ID
app.get('/api/clientes/:id', (req, res) => {
    const { id } = req.params;
    
    db.get('SELECT * FROM clientes WHERE id = ?', [id], (err, row) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (!row) {
            res.status(404).json({ error: 'Cliente no encontrado' });
            return;
        }
        res.json({ success: true, data: row });
    });
});

// PUT - Actualizar cliente
app.put('/api/clientes/:id', (req, res) => {
    const { id } = req.params;
    const { nombre, direccion, codigo_postal, identificacion, email, telefono } = req.body;
    
    db.run(`
        UPDATE clientes 
        SET nombre = ?, direccion = ?, codigo_postal = ?, identificacion = ?, email = ?, telefono = ?
        WHERE id = ?
    `, [nombre, direccion, codigo_postal, identificacion, email, telefono, id], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (this.changes === 0) {
            res.status(404).json({ error: 'Cliente no encontrado' });
            return;
        }
        res.json({ success: true, message: 'Cliente actualizado correctamente' });
    });
});

// DELETE - Desactivar cliente (soft delete)
app.delete('/api/clientes/:id', (req, res) => {
    const { id } = req.params;
    
    // Como la tabla clientes no tiene campo activo, eliminamos f√≠sicamente
    db.run('DELETE FROM clientes WHERE id = ?', [id], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (this.changes === 0) {
            res.status(404).json({ error: 'Cliente no encontrado' });
            return;
        }
        res.json({ success: true, message: 'Cliente eliminado correctamente' });
    });
});

// GET - Obtener todos los coches
app.get('/api/coches', (req, res) => {
    db.all('SELECT * FROM coches WHERE activo = 1 ORDER BY fecha_creacion DESC', (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ success: true, data: rows });
    });
});

// GET - Obtener coches disponibles para productos (con informaci√≥n de productos asociados)
app.get('/api/coches/disponibles', (req, res) => {
    db.all(`
        SELECT c.*, 
               CASE WHEN p.id IS NOT NULL THEN 1 ELSE 0 END as tiene_producto,
               p.precio as precio_producto,
               p.codigo as codigo_producto
        FROM coches c
        LEFT JOIN productos p ON c.matricula = p.codigo
        WHERE c.activo = 1 
        ORDER BY c.fecha_creacion DESC
    `, (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ success: true, data: rows });
    });
});

// GET - Obtener coche por ID
app.get('/api/coches/:id', (req, res) => {
    const { id } = req.params;
    
    db.get('SELECT * FROM coches WHERE id = ? AND activo = 1', [id], (err, row) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (!row) {
            res.status(404).json({ error: 'Coche no encontrado' });
            return;
        }
        res.json({ success: true, data: row });
    });
});

// POST - Crear nuevo coche
app.post('/api/coches', (req, res) => {
    const { matricula, chasis, color, kms, modelo } = req.body;
    
    db.run(`
        INSERT INTO coches (matricula, chasis, color, kms, modelo)
        VALUES (?, ?, ?, ?, ?)
    `, [matricula, chasis, color, kms, modelo], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ 
            success: true, 
            data: { 
                id: this.lastID, 
                matricula, 
                chasis, 
                color, 
                kms, 
                modelo 
            } 
        });
    });
});

// PUT - Actualizar coche
app.put('/api/coches/:id', (req, res) => {
    const { id } = req.params;
    const { matricula, chasis, color, kms, modelo } = req.body;
    
    db.run(`
        UPDATE coches 
        SET matricula = ?, chasis = ?, color = ?, kms = ?, modelo = ?
        WHERE id = ? AND activo = 1
    `, [matricula, chasis, color, kms, modelo, id], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (this.changes === 0) {
            res.status(404).json({ error: 'Coche no encontrado' });
            return;
        }
        res.json({ success: true, message: 'Coche actualizado correctamente' });
    });
});

// DELETE - Desactivar coche (soft delete)
app.delete('/api/coches/:id', (req, res) => {
    const { id } = req.params;
    
    db.run('UPDATE coches SET activo = 0 WHERE id = ?', [id], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        if (this.changes === 0) {
            res.status(404).json({ error: 'Coche no encontrado' });
            return;
        }
        res.json({ success: true, message: 'Coche desactivado correctamente' });
    });
});

// GET - Obtener todos los productos
app.get('/api/productos', (req, res) => {
    db.all('SELECT * FROM productos WHERE activo = 1 ORDER BY descripcion', (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ success: true, data: rows });
    });
});

// POST - Crear nuevo producto
app.post('/api/productos', (req, res) => {
    const { codigo, descripcion, precio, stock, categoria } = req.body;
    
    db.run(`
        INSERT INTO productos (codigo, descripcion, precio, stock, categoria)
        VALUES (?, ?, ?, ?, ?)
    `, [codigo, descripcion, precio, stock, categoria], function(err) {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json({ 
            success: true, 
            data: { 
                id: this.lastID, 
                codigo, 
                descripcion, 
                precio, 
                stock, 
                categoria 
            } 
        });
    });
});

// POST - Crear producto desde coche
app.post('/api/productos/desde-coche', (req, res) => {
    const { coche_id, precio, cantidad = 1 } = req.body;
    
    // Primero obtener los datos del coche
    db.get('SELECT * FROM coches WHERE id = ? AND activo = 1', [coche_id], (err, coche) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        
        if (!coche) {
            res.status(404).json({ error: 'Coche no encontrado' });
            return;
        }
        
        // Generar c√≥digo √∫nico basado en la matr√≠cula
        const codigo = `COCHE-${coche.matricula.replace(/[^A-Z0-9]/g, '')}`;
        
        // Generar descripci√≥n autom√°tica
        const descripcion = `${coche.modelo} - ${coche.color} - ${coche.kms.toLocaleString()} km - Chasis: ${coche.chasis}`;
        
        // Crear el producto
        db.run(`
            INSERT INTO productos (codigo, descripcion, precio, stock, categoria)
            VALUES (?, ?, ?, ?, ?)
        `, [codigo, descripcion, precio, cantidad, 'vehiculo'], function(err) {
            if (err) {
                res.status(500).json({ error: err.message });
                return;
            }
            
            res.json({ 
                success: true, 
                data: { 
                    id: this.lastID, 
                    codigo, 
                    descripcion, 
                    precio, 
                    stock: cantidad, 
                    categoria: 'vehiculo',
                    coche: coche
                } 
            });
        });
    });
});

// GET - Obtener todas las facturas (con paginaci√≥n y cach√©)
app.get('/api/facturas', async (req, res) => {
    try {
        const { page = 1, limit = 20, search = '', empresa_id = '', cliente_id = '', fecha_desde = '', fecha_hasta = '' } = req.query;
        
        // Usar cach√© si est√° disponible
        const cacheKey = `facturas:page:${page}:limit:${limit}:search:${search}:empresa:${empresa_id}:cliente:${cliente_id}:fecha_desde:${fecha_desde}:fecha_hasta:${fecha_hasta}`;
        const cachedResult = cacheManager.get(cacheKey);
        
        if (cachedResult) {
            return res.json({ success: true, data: cachedResult.data, pagination: cachedResult.pagination, cached: true });
        }
        
        // Construir consulta con filtros
        const joins = [
            { type: 'LEFT', table: 'clientes c', condition: 'f.cliente_id = c.id' },
            { type: 'LEFT', table: 'empresas e', condition: 'f.empresa_id = e.id' }
        ];
        
        let whereConditions = [];
        let whereParams = [];
        
        if (search) {
            whereConditions.push('(f.numero_factura LIKE ? OR c.nombre LIKE ? OR e.nombre LIKE ?)');
            whereParams.push(`%${search}%`, `%${search}%`, `%${search}%`);
        }
        
        if (empresa_id) {
            whereConditions.push('f.empresa_id = ?');
            whereParams.push(empresa_id);
        }
        
        if (cliente_id) {
            whereConditions.push('f.cliente_id = ?');
            whereParams.push(cliente_id);
        }
        
        if (fecha_desde) {
            whereConditions.push('f.fecha_emision >= ?');
            whereParams.push(fecha_desde);
        }
        
        if (fecha_hasta) {
            whereConditions.push('f.fecha_emision <= ?');
            whereParams.push(fecha_hasta);
        }
        
        const whereClause = whereConditions.length > 0 ? whereConditions.join(' AND ') : null;
        
        const result = await paginationManager.getPaginatedDataWithJoins('facturas f', joins, {
            page: parseInt(page),
            limit: parseInt(limit),
            where: whereClause,
            whereParams: whereParams,
            orderBy: 'f.fecha_emision',
            orderDirection: 'DESC',
            select: 'f.*, c.nombre as cliente_nombre, c.identificacion as cliente_identificacion, e.nombre as empresa_nombre, e.cif as empresa_cif, e.direccion as empresa_direccion'
        });
        
        // Guardar en cach√©
        cacheManager.set(cacheKey, result, 180); // 3 minutos TTL
        
        res.json({ success: true, data: result.data, pagination: result.pagination, cached: false });
        
    } catch (error) {
        console.error('‚ùå Error al obtener facturas:', error);
        res.status(500).json({ error: error.message });
    }
});

// POST - Crear nueva factura (Cumpliendo Ley Antifraude)
app.post('/api/facturas', async (req, res) => {
    try {
        const { 
            numero_factura, 
            empresa_id,
            cliente_id, 
            fecha_emision, 
            fecha_vencimiento, 
            subtotal, 
            igic, 
            total, 
            notas,
            productos,
            // Campos adicionales de Ley Antifraude
            fecha_operacion,
            tipo_documento = 'factura',
            metodo_pago = 'transferencia',
            referencia_operacion
        } = req.body;
        
        // Validar y obtener empresa_id v√°lido
        let empresaIdValido = empresa_id;
        
        // Si no se proporciona empresa_id o es inv√°lido, obtener la empresa principal
        if (!empresaIdValido || empresaIdValido === null || empresaIdValido === undefined) {
            console.log('‚ö†Ô∏è empresa_id no proporcionado, obteniendo empresa principal...');
            
            try {
                const empresaPrincipal = await new Promise((resolve, reject) => {
                    db.get(`
                        SELECT id FROM empresas 
                        WHERE nombre LIKE '%Telwagen%' OR id = 17
                        ORDER BY id LIMIT 1
                    `, (err, row) => {
                        if (err) reject(err);
                        else resolve(row);
                    });
                });
                
                if (empresaPrincipal) {
                    empresaIdValido = empresaPrincipal.id;
                    console.log(`‚úÖ Usando empresa principal ID: ${empresaIdValido}`);
                } else {
                    // Si no hay empresa principal, usar la primera empresa disponible
                    const primeraEmpresa = await new Promise((resolve, reject) => {
                        db.get("SELECT id FROM empresas ORDER BY id LIMIT 1", (err, row) => {
                            if (err) reject(err);
                            else resolve(row);
                        });
                    });
                    
                    if (primeraEmpresa) {
                        empresaIdValido = primeraEmpresa.id;
                        console.log(`‚úÖ Usando primera empresa disponible ID: ${empresaIdValido}`);
                    } else {
                        throw new Error('No hay empresas disponibles en la base de datos');
                    }
                }
            } catch (error) {
                console.error('‚ùå Error al obtener empresa v√°lida:', error.message);
                return res.status(400).json({ 
                    success: false, 
                    error: 'No se pudo determinar la empresa para la factura. Aseg√∫rate de tener al menos una empresa configurada.' 
                });
            }
        }
        
        // Verificar que la empresa existe
        const empresaExiste = await new Promise((resolve, reject) => {
            db.get("SELECT id, nombre FROM empresas WHERE id = ?", [empresaIdValido], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!empresaExiste) {
            return res.status(400).json({ 
                success: false, 
                error: `La empresa con ID ${empresaIdValido} no existe` 
            });
        }
        
        console.log(`‚úÖ Factura ser√° creada para empresa: ${empresaExiste.nombre} (ID: ${empresaIdValido})`);
        
        // Generar n√∫mero de serie √∫nico
        const numero_serie = sistemaIntegridad.generarNumeroSerie(empresaIdValido, numero_factura);
        
        // Preparar datos para hash de integridad
        const datosFactura = {
            numero_factura,
            empresa_id: empresaIdValido,
            cliente_id,
            fecha_emision,
            fecha_operacion: fecha_operacion || fecha_emision,
            subtotal,
            igic,
            total,
            productos: productos || []
        };
        
        // Generar hash de integridad
        const hash_documento = sistemaIntegridad.generarHashIntegridad(datosFactura);
        
        // Generar sellado temporal
        const selladoTemporal = sistemaIntegridad.generarSelladoTemporal(datosFactura);
        
        // Insertar factura con todos los campos de Ley Antifraude
        const query = `
            INSERT INTO facturas (
                numero_factura, empresa_id, cliente_id, fecha_emision, fecha_vencimiento,
                subtotal, igic, total, notas, numero_serie, fecha_operacion,
                tipo_documento, metodo_pago, referencia_operacion, hash_documento,
                sellado_temporal, estado_fiscal
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        
        const params = [
            numero_factura, empresaIdValido, cliente_id, fecha_emision, fecha_vencimiento,
            subtotal, igic, total, notas, numero_serie, fecha_operacion || fecha_emision,
            tipo_documento, metodo_pago, referencia_operacion || '', hash_documento,
            selladoTemporal.timestamp, 'pendiente'
        ];
        
        db.run(query, params, async function(err) {
            if (err) {
                console.error('‚ùå Error al crear factura:', err.message);
                res.status(500).json({ error: err.message });
                return;
            }
            
            const facturaId = this.lastID;
            
            try {
                // Insertar detalles de la factura
                if (productos && productos.length > 0) {
                    for (const producto of productos) {
                        const productoId = producto.id && producto.id > 0 ? producto.id : null;
                        
                        await new Promise((resolve, reject) => {
                            db.run(`
                                INSERT INTO detalles_factura (factura_id, producto_id, cantidad, precio_unitario, subtotal, igic, total, descripcion, tipo_impuesto)
                                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                            `, [facturaId, productoId, producto.cantidad, producto.precioUnitario, producto.subtotal, producto.impuesto, producto.total, producto.descripcion || null, producto.tipoImpuesto || 'igic'], function(err) {
                                if (err) {
                                    console.error('‚ùå Error al insertar detalle de factura:', err.message);
                                    reject(err);
                                } else {
                                    console.log('‚úÖ Detalle de factura insertado:', this.lastID);
                                    resolve();
                                }
                            });
                        });
                    }
                }
                
                // Registrar en auditor√≠a
                const datosCompletosFactura = {
                    id: facturaId,
                    numero_factura,
                    numero_serie,
                    empresa_id,
                    cliente_id,
                    fecha_emision,
                    fecha_operacion: fecha_operacion || fecha_emision,
                    subtotal,
                    igic,
                    total,
                    hash_documento,
                    sellado_temporal: selladoTemporal.timestamp
                };
                
                await sistemaAuditoria.registrarCreacionFactura(datosCompletosFactura);
                
                // Generar c√≥digo VeriFactu
                const codigoVeriFactu = sistemaIntegridad.generarCodigoVeriFactu(datosCompletosFactura);
                
                // Actualizar factura con c√≥digo VeriFactu
                db.run('UPDATE facturas SET codigo_verifactu = ? WHERE id = ?', [codigoVeriFactu, facturaId]);
                
                // Generar firma digital de la factura con certificado de empresa
                const datosFacturaParaFirma = {
                    ...datosCompletosFactura,
                    codigo_verifactu: codigoVeriFactu,
                    productos: productos || []
                };
                
                const resultadoFirma = await sistemaFirmaDigital.firmarDocumentoConEmpresa(empresa_id, datosFacturaParaFirma);
                
                if (resultadoFirma.success) {
                    const firmaDigital = {
                        firma: resultadoFirma.firma,
                        archivo: resultadoFirma.firma.archivo,
                        certificado: resultadoFirma.firma.certificado
                    };
                    
                    // Actualizar factura con informaci√≥n de firma digital
                    db.run('UPDATE facturas SET respuesta_aeat = ? WHERE id = ?', 
                        [JSON.stringify({ firma_digital: firmaDigital.firma, archivo_firma: firmaDigital.archivo }), facturaId]);
                    
                    console.log('üîê Factura firmada digitalmente:', firmaDigital.archivo);
                } else {
                    console.log('‚ö†Ô∏è No se pudo firmar la factura:', resultadoFirma.error);
                }
                
                console.log('‚úÖ Factura creada con cumplimiento de Ley Antifraude:', facturaId);
                
                res.json({ 
                    success: true, 
                    data: { 
                        id: facturaId, 
                        numero_factura,
                        numero_serie,
                        hash_documento,
                        sellado_temporal: selladoTemporal.timestamp,
                        codigo_verifactu: codigoVeriFactu,
                        total 
                    } 
                });
                
            } catch (error) {
                console.error('‚ùå Error en proceso de creaci√≥n de factura:', error);
                res.status(500).json({ error: 'Error en el proceso de creaci√≥n de factura' });
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error general en creaci√≥n de factura:', error);
        res.status(500).json({ error: 'Error interno del servidor' });
    }
});

// GET - Generar siguiente n√∫mero de factura por empresa
app.get('/api/facturas/siguiente-numero/:empresaId', (req, res) => {
    const empresaId = req.params.empresaId;
    const a√±o = new Date().getFullYear();
    
    // Primero obtener los datos de la empresa
    db.get(`
        SELECT nombre, cif, direccion FROM empresas WHERE id = ?
    `, [empresaId], (err, empresa) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        
        if (!empresa) {
            res.status(404).json({ error: 'Empresa no encontrada' });
            return;
        }
        
        // Generar prefijo basado en nombre y ubicaci√≥n
        const prefijo = generarPrefijoEmpresa(empresa.nombre, empresa.direccion);
        
        // Buscar el √∫ltimo n√∫mero de factura para esta empresa
        db.get(`
            SELECT MAX(CAST(SUBSTR(numero_factura, ${prefijo.length + 1}, 3) AS INTEGER)) as ultimo_numero
            FROM facturas 
            WHERE empresa_id = ? AND numero_factura LIKE '${prefijo}%/${a√±o}'
        `, [empresaId], (err, row) => {
            if (err) {
                res.status(500).json({ error: err.message });
                return;
            }
            
            const siguienteNumero = (row.ultimo_numero || 0) + 1;
            const numeroFormateado = `${prefijo}${siguienteNumero.toString().padStart(3, '0')}/${a√±o}`;
            
            res.json({ 
                success: true, 
                data: { 
                    numero_factura: numeroFormateado,
                    empresa_id: empresaId,
                    prefijo: prefijo,
                    empresa_nombre: empresa.nombre,
                    empresa_ubicacion: empresa.direccion
                } 
            });
        });
    });
});

// Funci√≥n para generar prefijo √∫nico por empresa y ubicaci√≥n
function generarPrefijoEmpresa(nombre, direccion) {
    // Extraer palabras clave del nombre
    const palabrasNombre = nombre.toLowerCase()
        .replace(/[^a-z\s]/g, '') // Solo letras y espacios
        .split(' ')
        .filter(palabra => palabra.length > 2); // Palabras de m√°s de 2 caracteres
    
    // Extraer c√≥digo postal o ciudad de la direcci√≥n
    const codigoPostal = direccion.match(/\d{5}/)?.[0] || '';
    const ciudad = extraerCiudad(direccion);
    
    // Generar prefijo basado en nombre y ubicaci√≥n
    let prefijo = '';
    
    if (palabrasNombre.length >= 2) {
        // Usar primeras letras de las dos primeras palabras
        prefijo = palabrasNombre[0].substring(0, 2) + palabrasNombre[1].substring(0, 1);
    } else if (palabrasNombre.length === 1) {
        // Usar primeras 3 letras de la palabra
        prefijo = palabrasNombre[0].substring(0, 3);
    } else {
        // Fallback: usar primeras 3 letras del nombre completo
        prefijo = nombre.toLowerCase().replace(/[^a-z]/g, '').substring(0, 3);
    }
    
    // Agregar identificador de ubicaci√≥n si es necesario
    if (ciudad) {
        const ciudadCode = ciudad.substring(0, 2).toUpperCase();
        prefijo += ciudadCode;
    } else if (codigoPostal) {
        // Usar √∫ltimos 2 d√≠gitos del c√≥digo postal
        prefijo += codigoPostal.substring(3, 5);
    }
    
    return prefijo.toUpperCase();
}

// Funci√≥n para extraer ciudad de la direcci√≥n
function extraerCiudad(direccion) {
    const ciudadesComunes = [
        'madrid', 'barcelona', 'valencia', 'sevilla', 'zaragoza', 'm√°laga', 'murcia',
        'palma', 'las palmas', 'bilbao', 'alicante', 'c√≥rdoba', 'valladolid', 'vigo',
        'gij√≥n', 'hospitalet', 'coru√±a', 'granada', 'elche', 'santa cruz', 'oviedo',
        'badalona', 'cartagena', 'terrassa', 'jerez', 'sabadell', 'm√≥stoles', 'alcal√°',
        'pamplona', 'fuenlabrada', 'almer√≠a', 'legan√©s', 'santander', 'castell√≥n',
        'burgos', 'albacete', 'getafe', 'salamanca', 'huelva', 'marbella', 'logro√±o',
        'badajoz', 'san sebasti√°n', 'le√≥n', 'c√°diz', 'tarragona', 'l√©rida', 'matar√≥',
        'santa coloma', 'algeciras', 'ja√©n', 'ourense', 'reus', 'torrelavega', 'el ejido',
        'lugo', 'santiago', 'ceuta', 'melilla', 'canarias', 'baleares', 'andaluc√≠a',
        'catalu√±a', 'galicia', 'castilla', 'arag√≥n', 'extremadura', 'navarra', 'rioja'
    ];
    
    const direccionLower = direccion.toLowerCase();
    
    for (const ciudad of ciudadesComunes) {
        if (direccionLower.includes(ciudad)) {
            return ciudad;
        }
    }
    
    return null;
}

// GET - Obtener factura por ID con detalles
app.get('/api/facturas/:id', (req, res) => {
    const facturaId = req.params.id;
    
    db.get(`
        SELECT f.*, c.nombre as cliente_nombre, c.direccion as cliente_direccion, c.identificacion as cliente_identificacion,
               e.nombre as empresa_nombre, e.cif as empresa_cif, e.direccion as empresa_direccion
        FROM facturas f 
        LEFT JOIN clientes c ON f.cliente_id = c.id 
        LEFT JOIN empresas e ON f.empresa_id = e.id
        WHERE f.id = ?
    `, [facturaId], (err, factura) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        
        if (!factura) {
            res.status(404).json({ error: 'Factura no encontrada' });
            return;
        }
        
        // Obtener detalles de la factura
        db.all(`
            SELECT df.*, p.codigo, COALESCE(df.descripcion, p.descripcion) as descripcion, COALESCE(df.tipo_impuesto, 'igic') as tipo_impuesto
            FROM detalles_factura df
            LEFT JOIN productos p ON df.producto_id = p.id
            WHERE df.factura_id = ?
        `, [facturaId], (err, detalles) => {
            if (err) {
                res.status(500).json({ error: err.message });
                return;
            }
            
            factura.detalles = detalles;
            res.json({ success: true, data: factura });
        });
    });
});

// GET - Generar XML VeriFactu para una factura
app.get('/api/facturas/:id/verifactu', async (req, res) => {
    try {
        const facturaId = req.params.id;
        
        // Obtener datos completos de la factura
        const factura = await new Promise((resolve, reject) => {
            db.get(`
                SELECT f.*, c.nombre as cliente_nombre, c.identificacion as cliente_identificacion,
                       c.direccion as cliente_direccion, c.codigo_postal as cliente_codigo_postal,
                       c.provincia as cliente_provincia, c.pais as cliente_pais,
                       c.codigo_pais as cliente_codigo_pais, c.regimen_fiscal as cliente_regimen_fiscal,
                       e.nombre as empresa_nombre, e.cif as empresa_cif, e.direccion as empresa_direccion,
                       e.codigo_postal as empresa_codigo_postal, e.provincia as empresa_provincia,
                       e.pais as empresa_pais, e.codigo_pais as empresa_codigo_pais,
                       e.regimen_fiscal as empresa_regimen_fiscal
                FROM facturas f 
                LEFT JOIN clientes c ON f.cliente_id = c.id 
                LEFT JOIN empresas e ON f.empresa_id = e.id
                WHERE f.id = ?
            `, [facturaId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!factura) {
            return res.status(404).json({ error: 'Factura no encontrada' });
        }
        
        // Obtener detalles de la factura
        const detalles = await new Promise((resolve, reject) => {
            db.all(`
                SELECT df.*, p.codigo, COALESCE(df.descripcion, p.descripcion) as descripcion, COALESCE(df.tipo_impuesto, 'igic') as tipo_impuesto
                FROM detalles_factura df
                LEFT JOIN productos p ON df.producto_id = p.id
                WHERE df.factura_id = ?
            `, [facturaId], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
        
        factura.detalles = detalles;
        
        // Generar XML VeriFactu
        const xmlVeriFactu = generadorVeriFactu.generarXMLVeriFactu(factura);
        
        // Validar XML
        const validacion = generadorVeriFactu.validarXMLVeriFactu(xmlVeriFactu);
        
        if (!validacion.valido) {
            return res.status(400).json({ 
                error: 'XML VeriFactu inv√°lido', 
                detalles: validacion.errores 
            });
        }
        
        res.json({
            success: true,
            data: {
                xml: xmlVeriFactu,
                validacion: validacion,
                factura_id: facturaId,
                numero_serie: factura.numero_serie
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error al generar XML VeriFactu:', error);
        res.status(500).json({ error: 'Error al generar XML VeriFactu' });
    }
});

// POST - Enviar factura a VeriFactu (simulado)
app.post('/api/facturas/:id/enviar-verifactu', async (req, res) => {
    try {
        const facturaId = req.params.id;
        
        // Obtener datos de la factura
        const factura = await new Promise((resolve, reject) => {
            db.get('SELECT * FROM facturas WHERE id = ?', [facturaId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!factura) {
            return res.status(404).json({ error: 'Factura no encontrada' });
        }
        
        // Generar XML VeriFactu
        const xmlVeriFactu = generadorVeriFactu.generarXMLVeriFactu(factura);
        
        // Simular env√≠o a AEAT
        const respuestaAEAT = generadorVeriFactu.generarRespuestaAEAT(xmlVeriFactu);
        
        // Actualizar factura con respuesta de AEAT
        db.run('UPDATE facturas SET respuesta_aeat = ?, estado_fiscal = ? WHERE id = ?', 
            [JSON.stringify(respuestaAEAT), respuestaAEAT.valido ? 'enviada' : 'error'], facturaId);
        
        // Registrar en auditor√≠a
        await sistemaAuditoria.registrarOperacion(
            'facturas',
            facturaId,
            'UPDATE',
            { estado_fiscal: factura.estado_fiscal },
            { estado_fiscal: respuestaAEAT.valido ? 'enviada' : 'error', respuesta_aeat: respuestaAEAT },
            'sistema'
        );
        
        res.json({
            success: true,
            data: {
                factura_id: facturaId,
                respuesta_aeat: respuestaAEAT,
                xml_enviado: xmlVeriFactu
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error al enviar a VeriFactu:', error);
        res.status(500).json({ error: 'Error al enviar a VeriFactu' });
    }
});

// GET - Obtener historial de auditor√≠a de una factura
app.get('/api/facturas/:id/auditoria', async (req, res) => {
    try {
        const facturaId = req.params.id;
        
        const historial = await sistemaAuditoria.obtenerHistorialAuditoria('facturas', facturaId);
        
        res.json({
            success: true,
            data: historial
        });
        
    } catch (error) {
        console.error('‚ùå Error al obtener historial de auditor√≠a:', error);
        res.status(500).json({ error: 'Error al obtener historial de auditor√≠a' });
    }
});

// GET - Verificar integridad de auditor√≠a
app.get('/api/auditoria/verificar-integridad', async (req, res) => {
    try {
        const resultado = await sistemaAuditoria.verificarIntegridadAuditoria();
        
        res.json({
            success: true,
            data: resultado
        });
        
    } catch (error) {
        console.error('‚ùå Error al verificar integridad:', error);
        res.status(500).json({ error: 'Error al verificar integridad' });
    }
});

// GET - Listar backups disponibles
app.get('/api/backup/listar', (req, res) => {
    try {
        const backups = sistemaBackup.listarBackups();
        
        res.json({
            success: true,
            data: backups
        });
        
    } catch (error) {
        console.error('‚ùå Error al listar backups:', error);
        res.status(500).json({ error: 'Error al listar backups' });
    }
});

// POST - Realizar backup manual
app.post('/api/backup/realizar', async (req, res) => {
    try {
        const resultado = await sistemaBackup.realizarBackup();
        
        res.json({
            success: true,
            data: resultado
        });
        
    } catch (error) {
        console.error('‚ùå Error al realizar backup:', error);
        res.status(500).json({ error: 'Error al realizar backup' });
    }
});

// POST - Restaurar desde backup
app.post('/api/backup/restaurar', async (req, res) => {
    try {
        const { archivo } = req.body;
        
        if (!archivo) {
            return res.status(400).json({ error: 'Archivo de backup requerido' });
        }
        
        const resultado = await sistemaBackup.restaurarBackup(archivo);
        
        res.json({
            success: true,
            data: { restaurado: resultado, archivo }
        });
        
    } catch (error) {
        console.error('‚ùå Error al restaurar backup:', error);
        res.status(500).json({ error: 'Error al restaurar backup' });
    }
});

// GET - Verificar integridad de backup
app.get('/api/backup/verificar/:archivo', async (req, res) => {
    try {
        const { archivo } = req.params;
        const integridadValida = await sistemaBackup.verificarIntegridadBackup(
            path.join('./backups', archivo)
        );
        
        res.json({
            success: true,
            data: { 
                archivo, 
                integridad_valida: integridadValida 
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error al verificar integridad del backup:', error);
        res.status(500).json({ error: 'Error al verificar integridad del backup' });
    }
});

// GET - Buscar cliente por identificaci√≥n
app.get('/api/clientes/buscar/:identificacion', (req, res) => {
    const identificacion = req.params.identificacion;
    
    db.get('SELECT * FROM clientes WHERE identificacion = ?', [identificacion], (err, row) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        
        if (!row) {
            res.status(404).json({ error: 'Cliente no encontrado' });
            return;
        }
        
        res.json({ success: true, data: row });
    });
});

// GET - Buscar producto por c√≥digo
app.get('/api/productos/buscar/:codigo', (req, res) => {
    const codigo = req.params.codigo;
    
    db.get('SELECT * FROM productos WHERE codigo = ? AND activo = 1', [codigo], (err, row) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        
        if (!row) {
            res.status(404).json({ error: 'Producto no encontrado' });
            return;
        }
        
        res.json({ success: true, data: row });
    });
});

// Endpoints de rendimiento y estad√≠sticas
app.get('/api/performance/stats', (req, res) => {
    try {
        const cacheStats = cacheManager.getStats();
        const memoryUsage = process.memoryUsage();
        
        res.json({
            success: true,
            data: {
                cache: cacheStats,
                memory: {
                    rss: Math.round(memoryUsage.rss / 1024 / 1024) + ' MB',
                    heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + ' MB',
                    heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + ' MB',
                    external: Math.round(memoryUsage.external / 1024 / 1024) + ' MB'
                },
                uptime: Math.round(process.uptime()) + ' seconds',
                nodeVersion: process.version,
                platform: process.platform
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/performance/cache/clear', (req, res) => {
    try {
        const { pattern } = req.body;
        
        if (pattern) {
            const deletedCount = cacheManager.delPattern(pattern);
            res.json({ success: true, message: `Cache cleared for pattern: ${pattern}`, deletedCount });
        } else {
            cacheManager.flush();
            res.json({ success: true, message: 'All cache cleared' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/performance/cache/stats', (req, res) => {
    try {
        const stats = cacheManager.getStats();
        res.json({ success: true, data: stats });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/performance/cache/preheat', async (req, res) => {
    try {
        await preheatCache();
        res.json({ success: true, message: 'Cache preheated successfully' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Endpoint para analizar rendimiento de consultas
app.post('/api/performance/analyze-query', async (req, res) => {
    try {
        const { query, params = [] } = req.body;
        
        if (!query) {
            return res.status(400).json({ error: 'Query is required' });
        }
        
        const analysis = await paginationManager.analyzeQueryPerformance(query, params);
        res.json({ success: true, data: analysis });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Funci√≥n para configurar endpoints de seguridad despu√©s de la inicializaci√≥n
function configurarEndpointsSeguridad() {
    // ========================================
    // ENDPOINTS DE SEGURIDAD Y VALIDACI√ìN FISCAL
    // ========================================

    // Endpoints de autenticaci√≥n
    app.post('/api/auth/login', async (req, res) => {
    try {
        const { username, password } = req.body;
        const ipAddress = req.ip || req.connection.remoteAddress;
        const userAgent = req.get('User-Agent');

        const resultado = await sistemaControlAcceso.autenticar(username, password, ipAddress, userAgent);
        
        // Registrar evento de login
        await sistemaLogsSeguridad.registrarLogin(
            resultado.usuario.id,
            resultado.usuario.username,
            ipAddress,
            userAgent,
            true
        );

        res.json({
            success: true,
            data: resultado
        });
    } catch (error) {
        // Registrar intento fallido
        await sistemaLogsSeguridad.registrarLogin(
            null,
            req.body.username,
            req.ip || req.connection.remoteAddress,
            req.get('User-Agent'),
            false
        );

        res.status(401).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/auth/logout', sistemaControlAcceso.middlewareAutenticacion(), async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        await sistemaControlAcceso.cerrarSesion(token);
        
        // Registrar evento de logout
        await sistemaLogsSeguridad.registrarLogout(
            req.usuario.id,
            req.usuario.username,
            req.ip || req.connection.remoteAddress
        );

        res.json({ success: true, message: 'Sesi√≥n cerrada correctamente' });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Endpoints de cifrado
app.post('/api/cifrado/cifrar', sistemaControlAcceso.middlewareAutenticacion(), 
         sistemaControlAcceso.middlewarePermisos('facturas:crear'), async (req, res) => {
    try {
        const { datos } = req.body;
        const resultado = sistemaCifrado.cifrar(datos);
        
        // Registrar evento de cifrado
        await sistemaLogsSeguridad.registrarCifrado(
            req.usuario.id,
            req.usuario.username,
            'cifrar',
            'datos_sensibles',
            req.ip || req.connection.remoteAddress
        );

        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/cifrado/descifrar', sistemaControlAcceso.middlewareAutenticacion(), 
         sistemaControlAcceso.middlewarePermisos('facturas:leer'), async (req, res) => {
    try {
        const { datosCifrados } = req.body;
        const resultado = sistemaCifrado.descifrar(datosCifrados);
        
        // Registrar evento de descifrado
        await sistemaLogsSeguridad.registrarCifrado(
            req.usuario.id,
            req.usuario.username,
            'descifrar',
            'datos_sensibles',
            req.ip || req.connection.remoteAddress
        );

        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Endpoints de validaci√≥n fiscal
app.post('/api/validacion/nif', async (req, res) => {
    try {
        const { nif } = req.body;
        const resultado = sistemaValidacionFiscal.validarNIF(nif);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/cif', async (req, res) => {
    try {
        const { cif } = req.body;
        const resultado = sistemaValidacionFiscal.validarCIF(cif);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/nie', async (req, res) => {
    try {
        const { nie } = req.body;
        const resultado = sistemaValidacionFiscal.validarNIE(nie);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/identificacion', async (req, res) => {
    try {
        const { identificacion } = req.body;
        const resultado = sistemaValidacionFiscal.validarIdentificacionFiscal(identificacion);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/pais', async (req, res) => {
    try {
        const { codigo } = req.body;
        const resultado = sistemaValidacionFiscal.validarCodigoPais(codigo);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/provincia', async (req, res) => {
    try {
        const { provincia } = req.body;
        const resultado = sistemaValidacionFiscal.validarProvincia(provincia);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/cliente', async (req, res) => {
    try {
        const datos = req.body;
        const resultado = sistemaValidacionFiscal.validarDatosFiscalesCliente(datos);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/validacion/empresa', async (req, res) => {
    try {
        const datos = req.body;
        const resultado = sistemaValidacionFiscal.validarDatosFiscalesEmpresa(datos);
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Endpoints de informaci√≥n de validaci√≥n
app.get('/api/validacion/paises', (req, res) => {
    res.json({
        success: true,
        data: sistemaValidacionFiscal.obtenerPaises()
    });
});

app.get('/api/validacion/provincias', (req, res) => {
    res.json({
        success: true,
        data: sistemaValidacionFiscal.obtenerProvinciasEspana()
    });
});

app.get('/api/validacion/regimenes', (req, res) => {
    res.json({
        success: true,
        data: sistemaValidacionFiscal.obtenerRegimenesFiscales()
    });
});

// Endpoints de logs de seguridad
app.get('/api/logs-seguridad', sistemaControlAcceso.middlewareAutenticacion(), 
        sistemaControlAcceso.middlewarePermisos('auditoria:leer'), async (req, res) => {
    try {
        const filtros = req.query;
        const logs = await sistemaLogsSeguridad.obtenerLogs(filtros);
        res.json({ success: true, data: logs });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/logs-seguridad/estadisticas', sistemaControlAcceso.middlewareAutenticacion(), 
        sistemaControlAcceso.middlewarePermisos('auditoria:leer'), async (req, res) => {
    try {
        const { fechaDesde, fechaHasta } = req.query;
        const estadisticas = await sistemaLogsSeguridad.obtenerEstadisticas(fechaDesde, fechaHasta);
        res.json({ success: true, data: estadisticas });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.get('/api/logs-seguridad/verificar-integridad', sistemaControlAcceso.middlewareAutenticacion(), 
        sistemaControlAcceso.middlewarePermisos('auditoria:verificar'), async (req, res) => {
    try {
        const resultado = await sistemaLogsSeguridad.verificarIntegridadLogs();
        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Endpoints de gesti√≥n de usuarios
app.get('/api/usuarios', sistemaControlAcceso.middlewareAutenticacion(), 
        sistemaControlAcceso.middlewarePermisos('usuarios:leer'), async (req, res) => {
    try {
        const query = 'SELECT id, username, rol, nombre, email, activo, ultimo_acceso FROM usuarios WHERE activo = 1';
        db.all(query, [], (err, rows) => {
            if (err) {
                res.status(500).json({ success: false, error: err.message });
                return;
            }
            res.json({ success: true, data: rows });
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/usuarios', sistemaControlAcceso.middlewareAutenticacion(), 
         sistemaControlAcceso.middlewarePermisos('usuarios:crear'), async (req, res) => {
    try {
        const datosUsuario = req.body;
        const resultado = await sistemaControlAcceso.crearUsuario(datosUsuario);
        
        // Registrar evento de creaci√≥n de usuario
        await sistemaLogsSeguridad.registrarGestionUsuario(
            req.usuario.id,
            req.usuario.username,
            'crear',
            datosUsuario.username,
            req.ip || req.connection.remoteAddress
        );

        res.json({ success: true, data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

    app.get('/api/roles', (req, res) => {
        res.json({
            success: true,
            data: sistemaControlAcceso.obtenerRoles()
        });
    });

    // ========================================
    // ENDPOINTS DE FIRMA DIGITAL
    // ========================================

    // Informaci√≥n del certificado
    app.get('/api/firma-digital/certificado', async (req, res) => {
        try {
            const info = await sistemaFirmaDigital.obtenerInformacionCertificado();
            res.json({ success: true, data: info });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Obtener certificados de Windows
    app.get('/api/firma-digital/certificados-windows', async (req, res) => {
        try {
            const resultado = await sistemaFirmaDigital.obtenerCertificadosWindows();
            res.json(resultado);
        } catch (error) {
            console.error('Error al obtener certificados de Windows:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Asociar certificado con empresa
    app.post('/api/firma-digital/asociar-certificado-empresa', async (req, res) => {
        try {
            const { empresaId, thumbprint } = req.body;
            
            if (!empresaId || !thumbprint) {
                return res.status(400).json({
                    success: false,
                    error: 'empresaId y thumbprint son requeridos'
                });
            }
            
            const resultado = await sistemaFirmaDigital.asociarCertificadoConEmpresa(empresaId, thumbprint);
            res.json(resultado);
        } catch (error) {
            console.error('Error al asociar certificado con empresa:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Obtener certificado asociado a empresa
    app.get('/api/firma-digital/certificado-empresa/:empresaId', async (req, res) => {
        try {
            const { empresaId } = req.params;
            
            const resultado = await sistemaFirmaDigital.obtenerCertificadoEmpresa(empresaId);
            res.json(resultado);
        } catch (error) {
            console.error('Error al obtener certificado de empresa:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Firmar documento con certificado de empresa
    app.post('/api/firma-digital/firmar-documento-empresa', async (req, res) => {
        try {
            const { empresaId, datosDocumento } = req.body;
            
            if (!empresaId || !datosDocumento) {
                return res.status(400).json({
                    success: false,
                    error: 'empresaId y datosDocumento son requeridos'
                });
            }
            
            const resultado = await sistemaFirmaDigital.firmarDocumentoConEmpresa(empresaId, datosDocumento);
            res.json(resultado);
        } catch (error) {
            console.error('Error al firmar documento con empresa:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Obtener todas las firmas digitales disponibles
    app.get('/api/firma-digital/firmas-disponibles', async (req, res) => {
        try {
            const resultado = await sistemaFirmaDigital.detectarTodasLasFirmasDisponibles();
            res.json(resultado);
        } catch (error) {
            console.error('Error al obtener firmas disponibles:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Obtener firmas disponibles para asignar a una empresa espec√≠fica
    app.get('/api/firma-digital/firmas-para-asignar/:empresaId?', async (req, res) => {
        try {
            const empresaId = req.params.empresaId ? parseInt(req.params.empresaId) : null;
            const resultado = await sistemaFirmaDigital.obtenerFirmasParaAsignar(empresaId);
            res.json(resultado);
        } catch (error) {
            console.error('Error al obtener firmas para asignar:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Verificar alertas de certificados pr√≥ximos a caducar
    app.get('/api/firma-digital/alertas-certificados', async (req, res) => {
        try {
            const resultado = await sistemaFirmaDigital.verificarAlertasCertificados();
            res.json(resultado);
        } catch (error) {
            console.error('Error al verificar alertas de certificados:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Cambiar certificado activo
    app.post('/api/firma-digital/cambiar-certificado', async (req, res) => {
        try {
            const { thumbprint } = req.body;
            
            if (!thumbprint) {
                return res.status(400).json({
                    success: false,
                    error: 'Thumbprint es requerido'
                });
            }
            
            const resultado = await sistemaFirmaDigital.cambiarCertificadoActivo(thumbprint);
            res.json(resultado);
        } catch (error) {
            console.error('Error al cambiar certificado:', error);
            res.status(500).json({ 
                success: false, 
                error: 'Error interno del servidor' 
            });
        }
    });

    // Firmar documento
    app.post('/api/firma-digital/firmar', async (req, res) => {
        try {
            const { datosDocumento } = req.body;
            const firma = sistemaFirmaDigital.firmarDocumento(datosDocumento);
            res.json({ success: true, data: firma });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Verificar firma
    app.post('/api/firma-digital/verificar', async (req, res) => {
        try {
            const { firmaCompleta, datosDocumento } = req.body;
            const verificacion = sistemaFirmaDigital.verificarFirma(firmaCompleta, datosDocumento);
            res.json({ success: true, data: verificacion });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Firmar factura espec√≠fica
    app.post('/api/facturas/:id/firmar', async (req, res) => {
        try {
            const facturaId = req.params.id;
            
            // Obtener datos de la factura
            const factura = await new Promise((resolve, reject) => {
                db.get(`
                    SELECT f.*, c.nombre as cliente_nombre, c.identificacion as cliente_identificacion,
                           e.nombre as empresa_nombre, e.cif as empresa_cif, e.direccion as empresa_direccion
                    FROM facturas f 
                    LEFT JOIN clientes c ON f.cliente_id = c.id 
                    LEFT JOIN empresas e ON f.empresa_id = e.id
                    WHERE f.id = ?
                `, [facturaId], (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                });
            });

            if (!factura) {
                return res.status(404).json({
                    success: false,
                    error: 'Factura no encontrada'
                });
            }

            // Obtener productos de la factura
            const productos = await new Promise((resolve, reject) => {
                db.all(`
                    SELECT df.*, p.descripcion as producto_descripcion
                    FROM detalles_factura df
                    LEFT JOIN productos p ON df.producto_id = p.id
                    WHERE df.factura_id = ?
                `, [facturaId], (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                });
            });

            // Preparar datos para firma
            const datosFactura = {
                ...factura,
                productos: productos
            };

            // Firmar factura con certificado de la empresa
            const resultadoFirma = await sistemaFirmaDigital.firmarDocumentoConEmpresa(factura.empresa_id, datosFactura);
            
            if (!resultadoFirma.success) {
                return res.status(400).json({
                    success: false,
                    error: `Error al firmar factura: ${resultadoFirma.error}`
                });
            }
            
            const firmaDigital = {
                firma: resultadoFirma.firma,
                archivo: resultadoFirma.firma.archivo,
                certificado: resultadoFirma.firma.certificado
            };

            // Actualizar factura con informaci√≥n de firma
            await new Promise((resolve, reject) => {
                db.run('UPDATE facturas SET respuesta_aeat = ? WHERE id = ?', 
                    [JSON.stringify({ firma_digital: firmaDigital.firma, archivo_firma: firmaDigital.archivo }), facturaId], 
                    (err) => {
                        if (err) reject(err);
                        else resolve();
                    });
            });

            res.json({ 
                success: true, 
                data: {
                    factura_id: facturaId,
                    numero_factura: factura.numero_factura,
                    firma: firmaDigital.firma,
                    archivo: firmaDigital.archivo,
                    timestamp: firmaDigital.timestamp
                }
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Verificar firma de factura
    app.get('/api/facturas/:id/verificar-firma', async (req, res) => {
        try {
            const facturaId = req.params.id;
            
            // Obtener datos de la factura
            const factura = await new Promise((resolve, reject) => {
                db.get(`
                    SELECT f.*, c.nombre as cliente_nombre, c.identificacion as cliente_identificacion,
                           e.nombre as empresa_nombre, e.cif as empresa_cif, e.direccion as empresa_direccion
                    FROM facturas f 
                    LEFT JOIN clientes c ON f.cliente_id = c.id 
                    LEFT JOIN empresas e ON f.empresa_id = e.id
                    WHERE f.id = ?
                `, [facturaId], (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                });
            });

            if (!factura) {
                return res.status(404).json({
                    success: false,
                    error: 'Factura no encontrada'
                });
            }

            // Obtener productos de la factura
            const productos = await new Promise((resolve, reject) => {
                db.all(`
                    SELECT df.*, p.descripcion as producto_descripcion
                    FROM detalles_factura df
                    LEFT JOIN productos p ON df.producto_id = p.id
                    WHERE df.factura_id = ?
                `, [facturaId], (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                });
            });

            // Preparar datos para verificaci√≥n
            const datosFactura = {
                ...factura,
                productos: productos
            };

            // Verificar si tiene firma digital
            let firmaCompleta = null;
            if (factura.respuesta_aeat) {
                try {
                    const respuestaAEAT = JSON.parse(factura.respuesta_aeat);
                    if (respuestaAEAT.firma_digital) {
                        firmaCompleta = respuestaAEAT.firma_digital;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error al parsear respuesta AEAT:', error.message);
                }
            }

            if (!firmaCompleta) {
                return res.json({
                    success: true,
                    data: {
                        factura_id: facturaId,
                        numero_factura: factura.numero_factura,
                        tiene_firma: false,
                        mensaje: 'La factura no tiene firma digital'
                    }
                });
            }

            // Verificar firma
            const verificacion = sistemaFirmaDigital.verificarFactura(datosFactura, firmaCompleta);

            res.json({ 
                success: true, 
                data: verificacion
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Listar firmas generadas
    app.get('/api/firma-digital/firmas', (req, res) => {
        try {
            const firmas = sistemaFirmaDigital.listarFirmas();
            res.json({ success: true, data: firmas });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Cargar firma espec√≠fica
    app.get('/api/firma-digital/firmas/:archivo', (req, res) => {
        try {
            const archivo = req.params.archivo;
            const firma = sistemaFirmaDigital.cargarFirma(archivo);
            res.json({ success: true, data: firma });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });

    // Generar certificado de producci√≥n
    app.post('/api/firma-digital/certificado-produccion', async (req, res) => {
        try {
            const datosEmpresa = req.body;
            const certificado = sistemaFirmaDigital.generarCertificadoProduccion(datosEmpresa);
            res.json({ success: true, data: certificado });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    });
}

// Manejo de errores
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Algo sali√≥ mal!' });
});

// Iniciar servidor
app.listen(PORT, () => {
    logger.systemEvent('Servidor backend iniciado', { 
        port: PORT, 
        host: HOST,
        environment: config.get('server.environment')
    });
    logger.info(`üì° API disponible en: http://localhost:${PORT}`);
    logger.info(`üìã Documentaci√≥n: http://localhost:${PORT}/`);
});

// Ruta de prueba
app.get('/', (req, res) => {
    const nombreEmpresa = configuracionEmpresa ? configuracionEmpresa.nombre : 'Generador de Facturas';
    res.json({ 
        message: `üöó API del ${nombreEmpresa}`,
        version: '2.0.0',
        empresa: configuracionEmpresa,
        features: {
            pagination: true,
            caching: true,
            performanceOptimization: true,
            leyAntifraude: true
        },
        endpoints: {
            clientes: '/api/clientes',
            productos: '/api/productos',
            facturas: '/api/facturas',
            empresas: '/api/empresas',
            coches: '/api/coches',
            siguienteNumero: '/api/facturas/siguiente-numero',
            performance: '/api/performance/stats',
            cache: '/api/performance/cache/stats'
        },
        pagination: {
            defaultLimit: config.get('pagination.defaultLimit'),
            maxLimit: config.get('pagination.maxLimit')
        },
        cache: {
            enabled: config.get('cache.enabled'),
            ttl: config.get('cache.ttl')
        }
    });
});

// Exportar la instancia de la base de datos para uso en otros m√≥dulos
module.exports = { db };
